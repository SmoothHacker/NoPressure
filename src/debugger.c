#include "debugger.h"char NoPressure_x64_regs[27][10] = {        "r15", "r14", "r13", "r12", "rbp",        "rbx", "r11", "r10", "r9", "r8", "rax",        "rcx", "rdx","rsi", "rdi", "orig_rax",        "rip", "cs", "eflags", "rsp", "ss", "fs_base",        "gs_base", "ds", "es", "fs", "gs"};void mainDebuggerLoop(dbgSession *dbgHandle) {    int wait_status;    int options = 0;    char line[250];    if (debugSetup(dbgHandle) < 0) {        fprintf(stderr, "DebugSetup failed to initialize");        exit(-1);    }    printf("Initialization successful\n\n");    printf("NoPressure> ");    while(fgets(line, 250, stdin) != NULL) {        int commandResult = handleCommandInput(line);        switch (commandResult) {            case PRINT_REGISTERS: printRegisters(dbgHandle); break;            case CONTINUE: continueExec(dbgHandle); break;            case QUIT: exit(0);            case SINGLE_STEP: singleStep(dbgHandle); break;            default: printf("Unknown Command\n"); break;        }        printf("NoPressure> ");    }};int handleCommandInput(char *line) {    if(!strcmp("info regs\n", line)) {        return PRINT_REGISTERS;    } else if (!strcmp("continue\n", line)) {        return CONTINUE;    } else if (!strcmp("q\n", line)) {        return QUIT;    } else if (!strcmp("s\n", line)) {        return SINGLE_STEP;    } else {        return -1;    }};int printRegisters(dbgSession *dbgHandle) {    ptrace(PTRACE_GETREGS, dbgHandle->PID, NULL, *dbgHandle->programRegs);    unsigned long long *regPtr = &dbgHandle->programRegs->rax;    for (int i = 0; i < 27; ++i) {        printf("%s: 0x%llx\n", NoPressure_x64_regs[i], *regPtr++);    }    return 0;};int continueExec(dbgSession *dbgHandle) {    ptrace(PTRACE_CONT, dbgHandle->PID, NULL, NULL);    int wait_status;    waitpid(dbgHandle->PID, &wait_status, 0);    return 0;};int singleStep(dbgSession *dbgHandle) {    ptrace(PTRACE_SINGLESTEP, dbgHandle->PID, NULL, NULL);    if (ptrace(PTRACE_SINGLESTEP, dbgHandle->PID, NULL, NULL) < 0) {        perror("[ERR] PTRACE_SINGLESTEP");        return -1;    }    int wait_status;    wait(&wait_status);    printRegisters(dbgHandle);    return 0;};int debugSetup(dbgSession *dbgHandle) {    // Read /proc/PID/maps to find loaded base address    char procMapsPath[17];    char *line = NULL;    uint64_t len;    sprintf(procMapsPath, "/proc/%d/maps", dbgHandle->PID);    FILE *mapsFD = fopen(procMapsPath, "r");    if(!mapsFD) {        fprintf(stderr, "[ERR] Couldn't open /proc/%d/maps\n", dbgHandle->PID);        return -1;    }    getline(&line, &len, mapsFD);    if(!strstr(line, dbgHandle->programName)) {        fprintf(stderr, "[ERR] First line doesn't contain program name\n[ERR] line: %s\n", line);        return -1;    }    sscanf(line, "%16lx-", &dbgHandle->baseAddress);#if DEBUG==1    fprintf(stderr, "[DEBUG] BaseAddress: %p\n[DEBUG] /proc/%d/maps line: %s", dbgHandle->baseAddress, dbgHandle->PID, line);#endif    free(line);    fclose(mapsFD);    // read elf file header to find entry address    dbgHandle->elfHeader = malloc(sizeof(Elf64_Ehdr));    dbgHandle->elfFD = fopen(dbgHandle->exePath, "rb");    if(!dbgHandle->elfFD) {        perror("[ERR] Couldn't open elf header");        return -1;    }    fread(dbgHandle->elfHeader, sizeof(*dbgHandle->elfHeader), 1, dbgHandle->elfFD);    printf("Entry Address: %p\n", dbgHandle->elfHeader->e_entry);    return 0;};