#include "debugger.h"char NoPressure_x64_regs[27][10] = {        "r15", "r14", "r13", "r12", "rbp",        "rbx", "r11", "r10", "r9", "r8", "rax",        "rcx", "rdx","rsi", "rdi", "orig_rax",        "rip", "cs", "eflags", "rsp", "ss", "fs_base",        "gs_base", "ds", "es", "fs", "gs"};void mainDebuggerLoop(dbgSession *dbgHandle) {    int wait_status;    int options = 0;    waitpid(dbgHandle->programPID, &wait_status, options);    char line[250];    if (debugSetup(dbgHandle) < 0) {        fprintf(stderr, "DebugSetup failed to initialize");        exit(-1);    }    printf("Initialization successful\n\n");    printf("NoPressure> ");    while(fgets(line, 250, stdin) != NULL) {        int commandResult = handleCommandInput(line);        switch (commandResult) {            case PRINT_REGISTERS: printRegisters(dbgHandle); break;            case CONTINUE: continueExec(dbgHandle); break;            case QUIT: exit(0);            case SINGLE_STEP: singleStep(dbgHandle); break;            default: printf("Unknown Command\n"); break;        }        printf("NoPressure> ");    }};int handleCommandInput(char *line) {    if(!strcmp("info registers\n", line)) {        return PRINT_REGISTERS;    } else if (!strcmp("continue\n", line)) {        return CONTINUE;    } else if (!strcmp("q\n", line)) {        return QUIT;    } else if (!strcmp("s\n", line)) {        return SINGLE_STEP;    } else {        return -1;    }};int printRegisters(dbgSession *dbgHandle) {    ptrace(PTRACE_GETREGS, dbgHandle->programPID, NULL, &dbgHandle->programRegs);    unsigned long long *regPtr = &dbgHandle->programRegs->rax;    for (int i = 0; i < 27; ++i) {        printf("%s: 0x%llx\n", NoPressure_x64_regs[i], *regPtr++);    }    return 0;};int continueExec(dbgSession *dbgHandle) {    ptrace(PTRACE_CONT, dbgHandle->programPID, NULL, NULL);    int wait_status;    waitpid(dbgHandle->programPID, &wait_status, 0);    return 0;};int singleStep(dbgSession *dbgHandle) {    ptrace(PTRACE_SINGLESTEP, dbgHandle->programPID, NULL, NULL);    int wait_status;    waitpid(dbgHandle->programPID, &wait_status, 0);    printRegisters(dbgHandle);    return 0;};int debugSetup(dbgSession *dbgHandle) {    // Read /proc/pid/maps to find loaded base address    char procMapsPath[17];    char *line;    uint64_t len;    sprintf(procMapsPath, "/proc/%d/maps", dbgHandle->programPID);    FILE *mapsFD = fopen(procMapsPath, "r");    getline(&line, &len, mapsFD);    if(!strstr(line, dbgHandle->programName)) {        return -1;    }    sscanf(line, "%16lx-", dbgHandle->baseAddress);    // Parse target's ELF header to find e_entry    free(line);    fclose(mapsFD);    return 0;};